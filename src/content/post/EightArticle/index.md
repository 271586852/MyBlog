---
title: 八股
publishDate: 2024-07-26 08:00:00
description: 'Markdown 是一种轻量级的「标记语言」。'
tags:
  - Markdown
coverImage: { src: './thumbnail.jpg', color: '#B4C6DA' }
language: '中文'
---

## STL

- vector扩容机制（如何扩容、扩容方式、移动语义、拷贝构造）
- 

###

本质是穷举，可以加上剪枝减少消耗。

从顶部到底部，从左到右，构造树形结构，集合的大小构成树的宽度、递归的深度。

回溯三部曲（返回值及参数、终止条件、遍历过程）

![alt text](image.png)


## C++八股

1. 多态的实现（静态多态和动态多态）

2. 类的对象内存模型是什么样的？（虚函数表和虚函数指针在内存中的存储）

3. 虚函数表和虚函数指针在C++中是如何实现多态的？

4. 内存对齐

5. 构造函数定义及分类

6. 析构函数可以是虚函数吗？

7. 拷贝构造函数？深拷贝和浅拷贝区别？

8. 继承、虚继承？

### 指针
9. 指针类型？
10. 指针函数、函数指针区别是什么？
11. 常量指针、指针常量、常量引用区别是什么？
12. 智能指针分类？
13. 循环引用如何出现和解决？
14. 指针和引用的区别？
15. 野指针的产生和如何避免？

### 堆栈
16. 内存中堆和栈的区别是什么？
17. 什么是堆、栈、内存泄漏、内存溢出？
18. 内存池是什么？
19. 什么是内存碎片？
20. 申请堆内存需要注意什么？

### 编译流程
21. 由源码编译到可执行文件的流程？
22. 动态链接和静态链接的区别？

### 语法层面
23. 静态成员函数和普通成员函数的区别？
24. 全局变量和局部变量的区别？
25. #ifndef/#define/#endif的作用？
26. C 和 C++ 中常见的变量定义方式有哪些？
27. 简单说明一下extern关键字，以及extern”C” 有什么作用？
28. 请说明一下static关键字？
29. 简单说说#include<> 和 #include""的区别是什么？
30. 简单说说什么是原码、什么是反码、什么是补码？
31. 请说说const关键字的用法？
32. 请说明struct和class并且说明他们有什么区别？
33. 什么是数组名，数组名和指针有什么区别？

### 内存
34. 简单介绍malloc如何使用？
35. malloc底层实现的流程？
36. 内存分配的方式有哪些？

37. 请你简单说说数组存放在哪里？
38. 请你介绍一下c/c++中变量的作用域都有哪些？
39. 请问sizeof与strlen的区别，简单说说？
40. 简述C++有几种传值方式之间的区别？
41. 指针用的多不，请问数组指针与指针数组的区别？
42. 请问NULL和nullptr区别？

### STL
43. STL中常用的容器有哪些？
44. 请你说说STL容器有哪些并且说一下时间复杂度？
45. 请说说vector和list有什么区别？
46. vector和deque的区别？
47. 请你说明一下STL底层数据结构实现？
48. 请你说说map和set区别差异？
49. 请你说说STL迭代器怎样删除元素？


## 计网
1. TCP和UDP的区别

- 连接类型和服务对象
- 首部
- 可靠性和传输方式
- 流量和拥塞控制
- 应用场景

| 特性             | TCP                     | UDP                     |
|------------------|-------------------------|-------------------------|
| **连接方式**         | 面向连接                | 无连接                  |
| **可靠性**           | 可靠                    | 不可靠                  |
| **数据流**           | 字节流                  | 数据报                  |
| **速度**             | 较慢                    | 较快                    |
| **流量控制**        | 有                      | 无                      |
| **拥塞控制**         | 有                      | 无                      |
| **头部开销**         | 较大（最小20字节）      | 较小（最小8字节）       |
| **错误检测**         | 完整错误检测和重传      | 基本错误检测，无重传   |
| **应用场景**         | 文件传输、网页浏览等    | 实时通信、视频流、游戏等 |

![alt text](image-8.png)

2. TCP三次握手和四次挥手

3. HTTP和HTTPS区别

| 特性             | HTTP                      | HTTPS                    |
|------------------|---------------------------|--------------------------|
| **全称**         | 超文本传输协议             | 安全超文本传输协议        |
| **加密**         | 无加密                     | 使用SSL/TLS加密协议      |
| **端口**         | 80端口                     | 443端口                  |
| **性能**         | 较快，但不安全             | 较慢，但更安全            |
| **安全性**       | 不安全，数据易被窃取      | 安全，数据加密，防篡改   |
| **验证**         | 无身份验证                 | 通过数字证书验证身份     |
| **URL格式**      | `http://`                  | `https://`               |
| **应用场景**     | 适用于不涉及敏感数据的场景 | 适用于敏感数据传输（如银行支付、电子商务） |
| **浏览器提示**   | 显示“非安全”               | 显示绿色锁标志，表示安全 |


4. 键入网址到网页显示，期间发生了什么？

- 浏览器输入网址：解析 URL，获取协议、域名等信息。
- DNS 查询：解析域名为 IP 地址。
- 建立连接：建立 TCP 连接，进行 SSL/TLS 握手（如果是 HTTPS）。
- 发送 HTTP 请求：浏览器发送请求到服务器。
- 服务器响应：服务器处理请求并返回数据。
- 浏览器渲染：浏览器解析 HTML、CSS、JavaScript，渲染页面。


## OS

1. Linux 内核 vs Windows 内核 

![alt text](image.png)
`连接应用和硬件设备的桥梁`

四个基本能力：

- 管理进程、线程，决定哪个进程、线程使用 CPU，也就是进程调度的能力;
- 管理内存，决定内存的分配和回收，也就是内存管理的能力;
- 管理硬件设备，为进程与硬件设备之间提供通信能力，也就是硬件通信能力；
- 提供系统调用，如果应用程序要运行更高权限运行的服务，那么就需要有系统调用，它是用户程序与操作系统之间的接口。


内核具有很高的权限，可以控制cpu、内存、硬盘等硬件，而应用程序具有的权限很小，因此大多数操作系统，把内存分成了两个区域:

- 内核空间，这个内存空间只有内核程序可以访问
- 用户空间，这个内存空间专门给应用程序使用;

用户空间的代码只能访问一个局部的内存空间，而内核空间的代码可以访问所有内存空间。因此，当程序使用用户空间时，我们常说该程序在用户态执行，而当程序使内核空间时，程序则在内核态执行。

应用程序如果需要进入内核空间，就需要通过系统调用，下面来看看系统调用的过程:

![alt text](image-1.png)

内核程序执行在内核态，用户程序执行在用户态。当应用程序使用系统调用时，会产生一个中断。发生中断后， CPU 会中断当前在执行的用户程序，转而跳转到中断处理程序，也就是开始执行内核程序。内核处理完后，主动触发中断，把 CPU 执行权限交回给用户程序，回到用户态继续工作。

```
用户态程序执行
       |
       | 调用系统调用函数（如 write）
       |
       v
触发特权指令（如 syscall）
       |
       | -> CPU 从用户态切换到内核态
       |
       v
内核处理系统调用
       |
       | -> 执行系统调用逻辑
       |
       v
内核返回用户态
       |
       | -> CPU 恢复用户态上下文
       |
       v
用户态程序继续执行

```

![alt text](image-2.png)


### 内存管理
2. 虚拟内存

我们可以把进程所使用的地址「隔离」开来，即让操作系统为每个进程分配独立的一套「虚拟地址」，人人都有，大家自己玩自己的地址就行，互不干涉。但是有个前提每个进程都不能访问物理地址，至于虚拟地址最终怎么落到物理内存里，对进程来说是透明的，操作系统已经把这些都安排的明明白白了。

![alt text](image-3.png)

> [!NOTE]
>
> 操作系统会提供一种机制，将不同进程的虚拟地址和不同内存的物理地址映射起来

如果程序要访问虚拟地址的时候，由操作系统转换成不同的物理地址，这样不同的进程运行的时候，写入的是不同的物理地址，这样就不会冲突了。
于是，这里就引出了两种地址的概念:
- 我们程序所使用的内存地址叫做虚拟内存地址(Virtual Memory Address)
- 实际存在硬件里面的空间地址叫物理内存地址(Physical Memory Address)

![alt text](image-4.png)

> [!NOTE]
>
> 操作系统引入了虚拟内存，进程持有的虚拟地址会通过CPU 芯片中的内存管理单元(MMU)的映射关系，来转换变成物理地址，然后再通过物理地址访问内存


操作系统是如何管理虚拟地址与物理地址之间的关系?
- 主要有两种方式，分别是`内存分段`和`内存分页`

3. 内存分段

程序是由若干个逻辑分段组成的，如可由代码分段、数据分段、栈段、堆段组成。不同的段是有不同的属性的，所以就用分段(Segmentation)的形式把这些段分离出来。

> [!NOTE]
>
> 分段机制下，虚拟地址和物理地址是如何映射的?

分段机制下的虚拟地址由两部分组成，**段选择因子**和**段内偏移量**

![alt text](image-5.png)

分段的办法很好，解决了程序本身不需要关心具体的物理内存地址的问题，但它也有一些不足之处:
- 内存碎片
- 内存交换效率低

4. 内存碎片 
> [!NOTE]
>
> 我们先来看看，分段为什么会产生内存碎片的问题?

![alt text](image-6.png)

内存碎片主要分为，**内部内存碎片**和**外部内存碎片**。

解决「外部内存碎片」的问题就是**内存交换**

- 可以把音乐程序占用的那 256MB 内存写到硬盘上，然后再从硬盘上读回来到内存里。不过再读回的时候，我们不能装载回原来的位置，而是紧紧跟着那已经被占用了的512MB 内存后面。这样就能空缺出连续的 256MB 空间，于是新的 200MB 程序就可以装载进来。

> [!NOTE]
>
> 再来看看，分段为什么会导致内存交换效率低的问题?

对于多进程的系统来说，用分段的方式，外部内存碎片是很容易产生的，产生了外部内存碎片，那不得不重新 swap 内存区域，这个过程会产生性能瓶颈。
因为硬盘的访问速度要比内存慢太多了，每一次内存交换，我们都需要把一大段连续的内存数据写到硬盘上。

所以，**如果内存交换的时候，交换的是一个占内存空间很大的程序，这样整个机器都会显得卡顿**。

为了解决内存分段的「外部内存碎片和内存交换效率低」的问题，就出现了**内存分页**。


5. 内存分页

分段的好处就是能产生连续的内存空间，但是会出现「外部内存碎片和内存交换的空间太大」的问题。

要解决这些问题，那么就要想出能少出现一些内存碎片的办法。另外，当需要进行内存交换的时候，让需要交换写入或者从磁盘装载的数据更少一点，这样就可以解决问题了。这个办法，也就是**内存分页(Paging)**

**分页是把整个虚拟和物理内存空间切成一段段固定尺寸的大小**。这样一个连续并且尺寸固定的内存空间我们叫页(Page)。在 Linux下，每一页的大小为 4KB

虚拟地址与物理地址之间通过页表来映射，如下图：

![alt text](image-7.png)

页表是存储在内存里的，**内存管理单元(MMU)**就做将虚拟内存地址转换成物理地址的工作。

6. 段页式内存管理


7. malloc 是如何分配内存的？
通过**brk()**和**mmap()**两种方式。

- 如果用户分配的内存小于 128 KB，则通过 brk() 申请内存
- 如果用户分配的内存大于 128 KB，则通过 mmap() 申请内存

分配的是**虚拟内存**，虚拟内存不会映射到物理内存，这样就不会占用物理内存了。3

8. new 是如何分配内存的？

> [!NOTE]
>
> for循环可以理解是横向遍历，backtracking（递归）就是纵向遍历。



分层分阶

Markdown 是一种轻量级且易于使用的语法，用于为您的写作设计风格。

### 标题

文章内容较多时，可以用标题分段：

```markdown
# 标题 1

## 标题 2

## 大标题

### 小标题
```

标题预览会打乱文章的结构，所以在此不展示。

### 粗斜体

```markdown
_斜体文本_

**粗体文本**

**_粗斜体文本_**
```

预览：

_斜体文本_

**粗体文本**

**_粗斜体文本_**

### 链接

```markdown
文字链接 [链接名称](http://链接网址)
```

预览：

文字链接 [链接名称](http://链接网址)

### 行内代码

```markdown
这是一条 `单行代码`
```

预览：

这是一条 `行内代码`

### 代码块

````markdown
```js
// calculate fibonacci
function fibonacci(n) {
  if (n <= 1) return 1
  return fibonacci(n - 1) + fibonacci(n - 2)
}
```
````

预览：

```js
// calculate fibonacci
function fibonacci(n) {
  if (n <= 1) return 1
  return fibonacci(n - 1) + fibonacci(n - 2)
}
```

当前使用 shiki 作为代码高亮插件，支持的语言请参考 [shiki / languages](https://shiki.matsu.io/languages.html)。

### 行内公式

```markdown
这是一条行内公式 $e^{i\pi} + 1 = 0$
```

预览：

这是一条行内公式 $e^{i\pi} + 1 = 0$

### 公式块

```markdown
$$
\hat{f}(\xi) = \int_{-\infty}^{\infty} f(x) e^{-2\pi i x \xi} \, dx
$$
```

预览：

$$
\hat{f}(\xi) = \int_{-\infty}^{\infty} f(x) e^{-2\pi i x \xi} \, dx
$$

当前使用 KaTeX 作为数学公式插件，支持的语法请参考 [KaTeX Supported Functions](https://katex.org/docs/supported.html)。

#### 图片

```markdown
![CWorld](https://cravatar.cn/avatar/1ffe42aa45a6b1444a786b1f32dfa8aa?s=200)
```

预览：

![CWorld](https://cravatar.cn/avatar/1ffe42aa45a6b1444a786b1f32dfa8aa?s=200)

#### 删除线

```markdown
~~删除线~~
```

预览：

~~删除线~~

### 列表

普通无序列表

```markdown
- 1
- 2
- 3
```

预览：

- 1
- 2
- 3

普通有序列表

```markdown
1. GPT-4
2. Claude Opus
3. LLaMa
```

预览：

1. GPT-4
2. Claude Opus
3. LLaMa

列表里可以继续嵌套语法

### 引用

```markdown
> 枪响，雷鸣，剑起。繁花血景。
```

预览：

> 枪响，雷鸣，剑起。繁花血景。

引用里也可以继续嵌套语法。

### 换行

markdown 分段落是需要空一行的。

```markdown
如果不空行
就会在一段

第一段

第二段
```

预览：

如果不空行
就会在一段

第一段

第二段

### 分隔符

如果你有写分割线的习惯，可以新起一行输入三个减号`---` 或者星号 `***`。当前后都有段落时，请空出一行：

```markdown
---
```

预览：

---

## 高级技巧

### 行内 HTML 元素

目前只支持部分段内 HTML 元素效果，包括 `<kdb> <b> <i> <em> <sup> <sub> <br>` ，如

#### 键位显示

```markdown
使用 <kbd>Ctrl</kbd> + <kbd>Alt</kbd> + <kbd>Del</kbd> 重启电脑
```

预览：

使用 <kbd>Ctrl</kbd> + <kbd>Alt</kbd> + <kbd>Del</kbd> 重启电脑

#### 粗斜体

```markdown
<b> Markdown 在此处同样适用，如 _加粗_ </b>
```

预览：

<b> Markdown 在此处同样适用，如 _加粗_ </b>

### 其他 HTML 写法

#### 折叠块

```markdown
<details><summary>点击展开</summary>它被隐藏了</details>
```

预览：

<details><summary>点击展开</summary>它被隐藏了</details>

### 表格

```markdown
| 表头1 | 表头2 |
| ----- | ----- |
| 内容1 | 内容2 |
```

预览：

| 表头1 | 表头2 |
| ----- | ----- |
| 内容1 | 内容2 |

### 注释

```markdown
在引用的地方使用 [^注释] 来添加注释。

然后在文档的结尾，添加注释的内容（会默认于文章结尾渲染之）。

[^注释]: 这里是注释的内容
```

预览：

在引用的地方使用 [^注释] 来添加注释。

然后在文档的结尾，添加注释的内容（会默认于文章结尾渲染之）。

[^注释]: 这里是注释的内容

### To-Do 列表

```markdown
- [ ] 未完成的任务
- [x] 已完成的任务
```

预览：

- [ ] 未完成的任务
- [x] 已完成的任务

### 特别引用块

```markdown
> [!NOTE]
> 在浏览内容时，用户也应该知道的有用信息。

> [!TIP]
> 可以更好或更容易地完成事情的有用建议。

> [!IMPORTANT]
> 用户需要知道的关键信息。

> [!WARNING]
> 需要用户立即关注以避免问题的紧急信息。

> [!CAUTION]
> 就某些行为的风险或负面结果提供建议。
```

预览：

> [!NOTE]
> 在浏览内容时，用户也应该知道的有用信息。

> [!TIP]
> 可以更好或更容易地完成事情的有用建议。

> [!IMPORTANT]
> 用户需要知道的关键信息。

> [!WARNING]
> 需要用户立即关注以避免问题的紧急信息。

> [!CAUTION]
> 就某些行为的风险或负面结果提供建议。

### 符号转义

如果你的描述中需要用到 markdown 的符号，比如 \_ # \* 等，但又不想它被转义，这时候可以在这些符号前加反斜杠，如 `\_` `\#` `\*` 进行避免。

```markdown
\_不想这里的文本变斜体\_

\*\*不想这里的文本被加粗\*\*
```

预览：

\_不想这里的文本变斜体\_

\*\*不想这里的文本被加粗\*\*

---

## 内嵌 Astro 组件

源代码位于 `src/components` 目录下，一般不用于写作，而是用于页面的客制化。

你可以仿照现有组件的写法，自行添加新的组件。
